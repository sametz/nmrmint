"""
Provide functions for creating lineshapes suitable for plotting.

For non-DNMR calculations, inputs are lists of (frequency, intensity) tuples,
which then have Lorentzian distributions applied to them.

For DNMR calculations, the lineshapes are directly computed. Currently,
non-quantum mechanical formulas for two uncoupled spins and for two coupled
spins are used.
"""
import numpy as np


def lorentz(v, v0, I, w):
    """
    A lorentz function that takes linewidth at half intensity (w) as a
    parameter.
    :param v: Array of values at which to evaluate distribution.
    :param v0: Center of the distribution.
    :param I: relative intensity of the signal
    :param w: Peak width at half max intensity

    :returns: Distribution evaluated at points in x.
    """
    # Adding a height scaling factor so that peak intensities are lowered as
    # they are more broad. If I is the intensity with a default w of 0.5 Hz:
    scaling_factor = 0.5 / w  # i.e. a 1 Hz wide peak will be half as high
    return scaling_factor * I * (
            (0.5 * w) ** 2 / ((0.5 * w) ** 2 + (v - v0) ** 2))


def add_signals(linspace, peaklist, w):
    """
    Given a numpy linspace, a spectrum as a list of (frequency, intensity)
    tuples, and a linewidth, returns an array of y coordinates for the
    lineshape.

    :param linspace: a numpy linspace of x coordinates for the lineshape.
    :param peaklist: a list of (frequency, intensity) tuples
    :param w: peak width at half maximum intensity
    :returns: array of y coordinates for the lineshape
    """
    result = lorentz(linspace, peaklist[0][0], peaklist[0][1], w)
    for v, i in peaklist[1:]:
        result += lorentz(linspace, v, i, w)
    return result


def nmrplot(spectrum, y=1):
    """
    A no-frills routine that plots spectral simulation data.
    :param spectrum: A list of (frequency, intensity) tuples
    :param y: max intensity
    """
    import matplotlib.pyplot as plt

    spectrum.sort()  # Could become costly with larger spectra
    l_limit = spectrum[0][0] - 50
    r_limit = spectrum[-1][0] + 50
    x = np.linspace(l_limit, r_limit, 800)
    plt.ylim(-0.1, y)
    plt.gca().invert_xaxis()  # reverses the x axis
    # noinspection PyTypeChecker
    plt.plot(x, add_signals(x, spectrum, w=1))

    plt.show()
    return


# def tkplot_current(spectrum, w=0.5, spectrometer_frequency=300):
#     # TODO: delete when no longer needed
#     """Generate linspaces of x and y coordinates suitable for plotting on a
#     matplotlib tkinter current_canvas. An x-range suitable for a "current
#     plot" zoom is hard-coded in (minimum frequency -50 Hz from lowest
#     frequency peak; maximum frequency +50 Hz from highest frequency peak.)
#     :param spectrum: A list of (frequency, intensity) tuples
#     :param w: peak width at half height
#     :return: a tuple of x and y coordinate linspaces
#     """
#     spectrum.sort()
#     # r_limit = spectrum[-1][0] + 50
#     # l_limit = spectrum[0][0] - 50
#     # # testing indicated the following was a sweetspot resolution
#     # x = np.linspace(l_limit, r_limit,  # 2400)
#     #                 40 * (r_limit - l_limit))
#     x = np.linspace(-1 * spectrometer_frequency,
#                     15 * spectrometer_frequency,
#                     160000)  # 0.01 Hz resolution on 1 GHz spectrometer
#
#     y = add_signals(x, spectrum, w)
#     return x, y


def tkplot(spectrum, w=0.5, spectrometer_frequency=300):
    """Generate linspaces of x and y coordinates suitable for plotting on a
    matplotlib tkinter current_canvas.

    Hard-coding a -1 to 15 ppm linspace, with resolution such that a 1 GHz
    spectrometer has 10 points per Hz.
    :param spectrum: A list of (frequency, intensity) tuples
    :param w: peak width at half height
    :param spectrometer_frequency: the frequency of the spectrometer (i.e
    frequency in MHz that 1H nuclei resonate at)
    :return: a tuple of x and y coordinate linspaces"""
    x = np.linspace(-1 * spectrometer_frequency,
                    15 * spectrometer_frequency,
                    160000)  # 0.01 Hz resolution on 1 GHz spectrometer
    y = add_signals(x, spectrum, w)
    return x, y


if __name__ == '__main__':

    reichdefault = (165.00, 135.00, 1.50, 0.50, 0.50, 50.00)
    x, y = dnmrplot_2spin(*reichdefault)

    def testplot(spectrum):
        """Used to test the spectral data generated by a simulation"""
        x, y = spectrum
        lower_limit = min(y)
        upper_limit = max(y)
        plt.ylim(lower_limit, upper_limit)
        plt.gca().invert_xaxis()  # reverses x-axis "NMR-Style"
        plt.plot(x, y)

    testplot((x, y))
    plt.show()
