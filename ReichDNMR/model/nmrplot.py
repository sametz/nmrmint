# import matplotlib.pyplot as plt
import numpy as np

from ReichDNMR.model.nmrmath import dnmr_AB, d2s_func


def lorentz(v, v0, I, w):
    """
    A lorentz function that takes linewidth at half intensity (w) as a
    parameter.
    :param v: Array of values at which to evaluate distribution.
    :param v0: Center of the distribution.
    :param w: Peak width at half max intensity

    :returns: Distribution evaluated at points in x.
    """
    return I * ((0.5 * w) ** 2 / ((0.5 * w) ** 2 + (v - v0) ** 2))


def add_signals(linspace, peaklist, w):
    """
    Given a numpy linspace a spectrum as a list of (frequency, intensity)
    tuples, and a linewidth, returns an array of y coordinates for the
    lineshape.

    :param linspace: a numpy linspace of x coordinates for the lineshape.
    :param peaklist: a list of (frequency, intensity) tuples
    :param w: peak width at half maximum intensity
    :returns: array of y coordinates for the lineshape
    """
    result = lorentz(linspace, peaklist[0][0], peaklist[0][1], w)
    for v, i in peaklist[1:]:
        result += lorentz(linspace, v, i, w)
    return result

# add_signals should supercede the adder function below--
# schedule for deletion
def adder(x, plist, Q=2):
    """
    :param x: the x coordinate (relative frequency in Hz)
    :param plist: a list of tuples of peak data (frequency, intensity)
    :param Q: the line width "fudge factor" used by lorentz2
    returns: the sum of the peak Lorentzian functions at x
    """
    total = 0
    for v, i in plist:
        total += lorentz2(x, v, i, Q)
    return total


def nmrplot(spectrum, y=1):
    """
    A no-frills routine that plots spectral simulation data.
    :param spectrum: A list of (frequency, intensity) tuples
    :param y: max intensity
    """
    spectrum.sort()  # Could become costly with larger spectra
    l_limit = spectrum[0][0] - 50
    r_limit = spectrum[-1][0] + 50
    x = np.linspace(l_limit, r_limit, 800)
    plt.ylim(-0.1, y)
    plt.gca().invert_xaxis()  # reverses the x axis
    # noinspection PyTypeChecker
    plt.plot(x, adder(x, spectrum, Q=4))

    plt.show()
    return


def tkplot(spectrum, w=0.5):
    spectrum.sort()
    r_limit = spectrum[-1][0] + 50
    l_limit = spectrum[0][0] - 50
    x = np.linspace(l_limit, r_limit, 2400)
    y = add_signals(x, spectrum, w)
    return x, y


def dnmrplot_2spin(va, vb, ka, Wa, Wb, pa):
    """
    plots the function nmrmath.dnmr_2spin
    Currently assumes va > vb
    """

    l_limit = vb - 50
    r_limit = va + 50
    x = np.linspace(l_limit, r_limit, 800)
    # y = dnmr_2spin(x, va, vb, ka, Wa, Wb, pa)

    # OR:

    dfunc = d2s_func(va, vb, ka, Wa, Wb, pa)
    y = dfunc(x)

    # OR:
    # y = reich(x, va, vb, ka, Wa, Wb, pa)

    return x, y


def dnmrplot_AB(v1, v2, J, k, W):
    """
    plots the function nmrmath.dnmr_AB.
    Currently assumes va > vb
    """

    l_limit = v2 - 50
    r_limit = v1 + 50
    x = np.linspace(l_limit, r_limit, 800)
    y = dnmr_AB(x, v1, v2, J, k, W)
    return x, y


if __name__ == '__main__':
    reichdefault = (165.00, 135.00, 1.50, 0.50, 0.50, 50.00)
    x, y = dnmrplot_2spin(*reichdefault)

    def testplot(spectrum):
        """Used to test the spectral data generated by a simulation"""
        x, y = spectrum
        l_limit = x[0] - 50
        r_limit = x[-1] + 50
        lower_limit = min(y)
        upper_limit = max(y)
        plt.ylim(lower_limit, upper_limit)
        plt.gca().invert_xaxis()  # reverses x-axis "NMR-Style"
        plt.plot(x, y)

    testplot((x, y))
    plt.show()
    # doublet = [(100, 1), (120, 1)]
    # nmrplot(doublet)
    # plt.show()
